{"componentChunkName":"component---src-templates-blog-tag-list-js","path":"/tags/bash/","result":{"data":{"site":{"siteMetadata":{"title":"CodeSpud"}},"allMarkdownRemark":{"totalCount":4,"edges":[{"node":{"excerpt":"If you work with Linux or Unix-like operating systems like Ubuntu or the MacOS, you might be familiar with Bourne-Again Shell or BASH for short. This article will show you that with a little elbow grease, you can have your BASH prompt work for you and heck maybe have a little fun with it.","html":"<p>If you work with Linux or Unix-like operating systems like Ubuntu or the MacOS, you might be familiar with Bourne-Again Shell or <a href=\"https://www.gnu.org/software/bash/bash.html\">BASH</a> for short. This article will show you that with a little elbow grease, you can have your BASH prompt work for you and heck maybe have a little fun with it.</p>\n<!--more-->\n<p>People tell me the invention of the GUI (graphical user interface) is the best thing that ever happened to modern computing. I beg to differ. Not all work is accomplished through the GUI nor is it efficient.</p>\n<p>I find myself working on the command line for work more and more — managing my servers even my Apple computer. So I get to spend much of my time on the command line. Launching commands like a stenographer recording the latest court drama. I realized very early how powerful the command line could be.</p>\n<p>But not having a GUI does not mean you should be happy with the default command prompt. Is this familiar?<figure></p>\n<p>\n  <a class=\"gatsby-resp-image-link\" href=\"/static/ad9bd2e81c124fa0c1135aab9bd4db0e/01e7c/boring.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n  \n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block;  max-width: 512px; margin-left: auto; margin-right: auto;\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 43.91891891891892%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAS0lEQVQoz9XLsQ2AMAwEQA8BvNyDscFPEZT9V4MBEFJCxfUntdZSTjObXy1PZE+6B4BhbCY8GLGp6oRmkpnh0ZlJru53RkfGBz/NF2VtNYgAofWlAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\">\n      <img class=\"gatsby-resp-image-image\" style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\" alt=\"boring\" title src=\"/static/ad9bd2e81c124fa0c1135aab9bd4db0e/01e7c/boring.png\" srcset=\"/static/ad9bd2e81c124fa0c1135aab9bd4db0e/12f09/boring.png 148w,\n/static/ad9bd2e81c124fa0c1135aab9bd4db0e/e4a3f/boring.png 295w,\n/static/ad9bd2e81c124fa0c1135aab9bd4db0e/01e7c/boring.png 512w\" sizes=\"(max-width: 512px) 100vw, 512px\">\n    </span>\n  </span>\n  \n  </a>\n     <figcaption>Boring command prompt!</figcaption></figure></p>\n<p>Using the table below we can build a BASH prompt that is not only pretty but saves us a few keystrokes as well.</p>\n<h2>BASH Special Characters Reference</h2>\n<table >\n  <tr>\n    <th>\n      Special character\n    </th>\n    \n    <th align=\"left\">\n      Description\n    </th>\n    \n    <th>\n      Special character\n    </th>\n    \n    <th align=\"left\">\n      Description\n    </th>\n  </tr>\n  \n  <tr>\n    <td align=\"center\">\n      \\a\n    </td>\n    \n    <td>\n      an ASCII bell character (07)\n    </td>\n    \n    <td align=\"center\">\n      \\d\n    </td>\n    \n    <td>\n      the date in &#8220;Weekday Month Date&#8221; format (e.g., &#8220;Tue May 26&#8221;)\n    </td>\n  </tr>\n  \n  <tr>\n    <td align=\"center\">\n      \\]\n    </td>\n    \n    <td>\n      end a sequence of non-printing characters\n    </td>\n    \n    <td align=\"center\">\n      \\e\n    </td>\n    \n    <td>\n      an ASCII escape character (033)\n    </td>\n  </tr>\n  \n  <tr>\n    <td align=\"center\">\n      \\h\n    </td>\n    \n    <td>\n      the hostname up to the first `.&#8217;\n    </td>\n    \n    <td align=\"center\">\n      \\H\n    </td>\n    \n    <td>\n      the hostname\n    </td>\n  </tr>\n  \n  <tr>\n    <td align=\"center\">\n      \\j\n    </td>\n    \n    <td>\n      the number of jobs currently managed by the shell\n    </td>\n    \n    <td align=\"center\">\n      \\l\n    </td>\n    \n    <td>\n      the basename of the shell&#8217;s terminal device name\n    </td>\n  </tr>\n  \n  <tr>\n    <td align=\"center\">\n      \\n\n    </td>\n    \n    <td>\n      newline\n    </td>\n    \n    <td align=\"center\">\n      \\r\n    </td>\n    \n    <td>\n      carriage return\n    </td>\n  </tr>\n  \n  <tr>\n    <td align=\"center\">\n      \\s\n    </td>\n    \n    <td>\n      the name of the shell, the basename of $0 (the portion following the final slash)\n    </td>\n    \n    <td align=\"center\">\n      \\t\n    </td>\n    \n    <td>\n      the current time in 24-hour HH:MM:SS format\n    </td>\n  </tr>\n  \n  <tr>\n    <td align=\"center\">\n      \\T\n    </td>\n    \n    <td>\n      the current time in 12-hour HH:MM:SS format\n    </td>\n    \n    <td align=\"center\">\n      \\@\n    </td>\n    \n    <td>\n      the current time in 12-hour am/pm format\n    </td>\n  </tr>\n  \n  <tr>\n    <td align=\"center\">\n      \\A\n    </td>\n    \n    <td>\n      the current time in 24-hour HH:MM format\n    </td>\n    \n    <td align=\"center\">\n      \\u\n    </td>\n    \n    <td>\n      the username of the current user\n    </td>\n  </tr>\n  \n  <tr>\n    <td align=\"center\">\n      \\v\n    </td>\n    \n    <td>\n      the version of bash (e.g., 2.00)\n    </td>\n    \n    <td align=\"center\">\n      \\V\n    </td>\n    \n    <td>\n      the release of bash, version + patchelvel (e.g., 2.00.0)\n    </td>\n  </tr>\n  \n  <tr>\n    <td align=\"center\">\n      \\w\n    </td>\n    \n    <td>\n      the current working directory\n    </td>\n    \n    <td align=\"center\">\n      \\W\n    </td>\n    \n    <td>\n      the basename of the current working directory\n    </td>\n  </tr>\n  \n  <tr>\n    <td align=\"center\">\n      \\!\n    </td>\n    \n    <td>\n      the history number of this command\n    </td>\n    \n    <td align=\"center\">\n      \\#\n    </td>\n    \n    <td>\n      the command number of this command\n    </td>\n  </tr>\n  \n  <tr>\n    <td align=\"center\">\n      \\$\n    </td>\n    \n    <td>\n      if the effective UID is 0, a #, otherwise a $\n    </td>\n    \n    <td align=\"center\">\n      \\nnn\n    </td>\n    \n    <td>\n      the character corresponding to the octal number nnn\n    </td>\n  </tr>\n  \n  <tr>\n    <td align=\"center\">\n      \\\\\n    </td>\n    \n    <td>\n      a backslash\n    </td>\n    \n    <td align=\"center\">\n      \\[\n    </td>\n    \n    <td>\n      begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt\n    </td>\n  </tr>\n  \n  <tr>\n    <td align=\"center\">\n      \\D{format}\n    </td>\n    \n    <td colspan=\"3\">\n      the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-specific time representation. The braces are required\n    </td>\n  </tr>\n</table>\n<h2>Change the Bash Prompt</h2>\n<p>The environment variable we want to modify is <strong>PS1</strong>.<figure></p>\n<p>\n  <a class=\"gatsby-resp-image-link\" href=\"/static/f45264fdce8f784f7c300350495a6407/d38a6/editPS1.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n  \n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block;  max-width: 376px; margin-left: auto; margin-right: auto;\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 23.64864864864865%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsTAAALEwEAmpwYAAABD0lEQVQY02OYM3fuggWLenp6+/r7J02eVlTSkJpemJufl5GZXVRckpaRkZmTl5Obl5dfkFdQlJ2bl5qeUVpeGR0d7e3tzeDr7+/o5OTn7+fm5mFrY5iTpR4RJi8hqSohIausrCIlLSUjKycrKysvJ6+gqKiopCQjI6OioiohLs7Hx8eQl58PNLeurjY/vyg7K/7+TemHNxkSYgTs7XWtrC11dHUMjIwNjQzNLcw11NWEhYXFxcVFRUWBpKSkJIO7m5udnZ25uZmlpYWpqa21taq7q7C3p0hUhLS5mY6SsoqaujoQaWhoqiorAi1EBgzc3FyCgoICIACiBYVE+fkl+PiArhID2gO0RAQGIBYiAwBQhUTk+CyD/wAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;\">\n      <img class=\"gatsby-resp-image-image\" style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\" alt=\"editps1\" title src=\"/static/f45264fdce8f784f7c300350495a6407/d38a6/editPS1.png\" srcset=\"/static/f45264fdce8f784f7c300350495a6407/12f09/editPS1.png 148w,\n/static/f45264fdce8f784f7c300350495a6407/e4a3f/editPS1.png 295w,\n/static/f45264fdce8f784f7c300350495a6407/d38a6/editPS1.png 376w\" sizes=\"(max-width: 376px) 100vw, 376px\">\n    </span>\n  </span>\n  \n  </a>\n     </figure></p>\n<p>Using the reference table above we can break down the current prompt as</p>\n<ul>\n<li><em>\\u</em> – the current user</li>\n<li><em>\\h</em> – the computer’s hostname</li>\n<li><em>\\w</em> – the current working directory</li>\n</ul>\n<p>Not very useful is it? Let’s change that.</p>\n<p>By modifying the PS1 variable and exporting it with the command below we can manipulate the prompt to output anything we want.<figure></p>\n<p>\n  <a class=\"gatsby-resp-image-link\" href=\"/static/4ca4fe36197c24f556104151e17bae2c/f2205/bash_prompt_smiley.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n  \n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block;  max-width: 476px; margin-left: auto; margin-right: auto;\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 27.7027027027027%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsTAAALEwEAmpwYAAABEUlEQVQY02P4iwT+4Aa/f//5/+/Pi4+/H77/8/jDn7df//789ZvhP3Hg3z8Q+eDj/8NP/x949O/Ys39//v1n6O7q6uzs7Ovr6+7urq9vqK2traysrKkBklUgUF0DFKmpqamorKyrqysoyCvJy8yq6sorrc7LyWKIiIj08/dz9/BwcHDQ0NBUVFCUkpJWUFCUlZOTBQI5OUVFRSAtKSWlpKzMycnFxsTAIWvI6VDKycLAUFBYmJmRmZqWFhUdbWfvYG5upqevb2pqZmhkZAAEhkYmJqZArpaWlr6BARDp6unpGxiqGVgCDWWor6trbm5uBAN3Dy+gE4DagIqARsjLyysqAu1TVlFRkUMF0pJiEhISAAkmtl0Qk+PGAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\">\n      <img class=\"gatsby-resp-image-image\" style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\" alt=\"bash_prompt_smiley\" title src=\"/static/4ca4fe36197c24f556104151e17bae2c/f2205/bash_prompt_smiley.png\" srcset=\"/static/4ca4fe36197c24f556104151e17bae2c/12f09/bash_prompt_smiley.png 148w,\n/static/4ca4fe36197c24f556104151e17bae2c/e4a3f/bash_prompt_smiley.png 295w,\n/static/4ca4fe36197c24f556104151e17bae2c/f2205/bash_prompt_smiley.png 476w\" sizes=\"(max-width: 476px) 100vw, 476px\">\n    </span>\n  </span>\n  \n  </a>\n     <figcaption>Add a smiley</figcaption></figure></p>\n<p>Below is my favorite bash prompt which I install for all my servers and even my workstation. I can easily see important details like the hostname – very important if you find yourself managing multiple terminal windows and you can distinguish between windows. This configuration also shows the load averages, the current date and time and the working directory. The color helps to give it contrast to the monotonous black on white default of most terminal windows.<figure></p>\n<p>\n  <a class=\"gatsby-resp-image-link\" href=\"/static/c3af717b947ea9ad65a2f789837478c1/073e9/mybashpromot_in_action.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n  \n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 51.35135135135135%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/UlEQVQoz0WR227aQBCGfdkkBh+wd71r4zPmVAPGdjBgSCDEGAgUNYUmrVKpjUgPSqtUqlT1omovetX3aJ+zK5KK1Wg0u6N//08zVMU3sCu5rezpmNZLgmJhoygbFWxZVmD7rwfJZjj4nC4/TqYdzzQsCSMZ/j9UNTq6fnlxOT1bxL3ED3KCuJ9h6CzHCgBjMI/8N6vVehi/6LXnQyMMZEXWIAQP4thp3vW7N+PZ1+ngz4erm+lokw7fTUZlxGMIufrM8mOzbOcdwywXZT0PoLhzjl0nHK5Ub2xy9HHUn3S6adicNR9XWnNt+Uuza/XQa/aicr2gOUh1sISknbgbd9zbv+7J2rAU7nCV5YUszxNw8PQ3jC4g80i12rLiEFJRAGDnuhW7oas3ikkiv70WSy6QTaQVsFrCtq5UkWmZDbMQukrR0QoIQYwQRtJ9EAAKJ3ewkQI2I4oESMKStH2HQEJAzEGzCkafDlh2j2EOWG6P5UimOX6fYXOiSEl2XagO6Gwmw+c4QSANEiLYzlOSgMDnVf3VJN2M+ptkcDs+vjpqk+L9ZFSzTIrlmCTwfl6efzlf/Hi+/L5+8u3ZwtY1QRQJAfkDQTD0G9P24Wnoz6KA5BPfS6OwaOgUaRt5JSg5nlOo2abv2K1KSVXkB/PtTjMcR7NsZstM6vsrwf4HTuNgNuEOI80AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;\">\n      <img class=\"gatsby-resp-image-image\" style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\" alt=\"mybashpromot_in_action\" title src=\"/static/c3af717b947ea9ad65a2f789837478c1/fcda8/mybashpromot_in_action.png\" srcset=\"/static/c3af717b947ea9ad65a2f789837478c1/12f09/mybashpromot_in_action.png 148w,\n/static/c3af717b947ea9ad65a2f789837478c1/e4a3f/mybashpromot_in_action.png 295w,\n/static/c3af717b947ea9ad65a2f789837478c1/fcda8/mybashpromot_in_action.png 590w,\n/static/c3af717b947ea9ad65a2f789837478c1/073e9/mybashpromot_in_action.png 719w\" sizes=\"(max-width: 590px) 100vw, 590px\">\n    </span>\n  </span>\n  \n  </a>\n     </figure></p>\n<h2>Make it Permanent</h2>\n<p>To make your BASH prompt permanent, just edit ~/.bash_profile or ~/.bashrc or ~/.profile or run the command<figure></p>\n\n  <a class=\"gatsby-resp-image-link\" href=\"/static/8d2457d18e004d7c91b1678654e982c6/d44c9/make_bashprompt_permanent.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n  \n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 25.675675675675674%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA1UlEQVQY03WM626CMACF+wzQC1PZqDBqiwS06wWmKNQFl8UfvsSM7/8CQ2IWs2Rfzo+Tk5wPdP2+P7vL9bs9NnorbaPr1tTOdPvWVQe3Pbjm43P31W6cqWz9vrFVZaxVWkv5BnKZ6U4eT73ZaVYmYsUzuVgqoaQq07XKVcFXaybj5ySa05QxGtEwDD3P830f0JimPCnKQuSCCcYzHr/Oo/hFcL4U+YLxSTCZBbPp05QQgjEmI8EIwAgjiAYN9OFQbkH4NiIIx+DhQu6fP4BfzSOPevI/P7ARKxokV/ZIAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\">\n      <img class=\"gatsby-resp-image-image\" style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\" alt=\"Make your bash prompt permanent\" title src=\"/static/8d2457d18e004d7c91b1678654e982c6/fcda8/make_bashprompt_permanent.png\" srcset=\"/static/8d2457d18e004d7c91b1678654e982c6/12f09/make_bashprompt_permanent.png 148w,\n/static/8d2457d18e004d7c91b1678654e982c6/e4a3f/make_bashprompt_permanent.png 295w,\n/static/8d2457d18e004d7c91b1678654e982c6/fcda8/make_bashprompt_permanent.png 590w,\n/static/8d2457d18e004d7c91b1678654e982c6/d44c9/make_bashprompt_permanent.png 722w\" sizes=\"(max-width: 590px) 100vw, 590px\">\n    </span>\n  </span>\n  \n  </a>\n      \n\n<h2>Ideas</h2>\n<ol>\n<li>Count the files in the current directory</li>\n<li>Display in blinking colors the last line of a todo list</li>\n<li>Display CPU/Memory/Disk usage</li>\n<li>Display command to pull up a help screen</li>\n<li>Echo a smiley if the system is working in top condition</li>\n</ol>\n<p>There you have it, you can now work on the command line with a little bit more help. The key here is to be creative and think of what you want your bash prompt to have. Enjoy!</p>","fields":{"slug":"/make-bash-prompt-work/"},"frontmatter":{"date":"November 14, 2016","title":"Make Your Bash Prompt Work For You","featured_image":"/assets/2016/11/mybashpromot_in_action.png","tags":["bash","console"]}}},{"node":{"excerpt":"You compiled and installed a linux binary or made a nifty script but you don’t want to mess the server bin tree. So you placed it in an isolated folder like so:","html":"<p>You compiled and installed a linux binary or made a nifty script but you don’t want to mess the server bin tree. So you placed it in an isolated folder like so:</p>\n<!--more-->\n<h6>Level: Beginner, Intermediate</h6>\n<div style=\"margin-left: 1em; margin-right: 1em; text-align: center;\">\n  <img src=\"//1.bp.blogspot.com/_BBS5bkzuLXM/Srw5tM3OeRI/AAAAAAAACjE/qLCjLDvRLHo/s200/punk+penguin.png\" /><br />Yeah your a rockstar!\n</div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">  /usr/local/myscripts/really/great/work/bin/myutility</code></pre></div>\n<p>You go on with business as usual. But soon you got tired of typing the whole path or changing folders every time you need the app. You could simplify your life by making a symbolic link(shortcut) or a wrapper script and place it on a more convenient path like /bin or /usr/bin. But you realize that would be defeating your original intent. what do you do? <!--more--></p>\n<p><a name='more'></a><br>\nSimple. Do what experts do. Use “export” to modify the PATH environment variable.</p>\n<div>\n  > help export </p> \n  \n  <p>\n    export: export [-nf] [name[=value] &#8230;] or export -p <br />NAMEs are marked for automatic export to the environment of subsequently executed commands. If the -f option is given, the NAMEs refer to functions. If no NAMEs are given, or if `-p&#8217; is given, a list of all names that are exported in this shell is printed. An argument of `-n&#8217; says to remove the export property from subsequent NAMEs. An argument of `&#8211;&#8216; disables further option processing.</div> \n    \n    <p>\n      To get an idea, try this command on the console:\n    </p>\n    \n    <div>\n      > echo $PATH</p> \n      \n      <p>\n        /usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</div> \n        \n        <p>\n        </p>\n        \n        <p>\n          The above value is a typical &#8220;root&#8221; PATH for a fresh text-only CentOS installation &#8211; so don&#8217;t fret if you got something different. This will grow in time the more you install applications. Anyway, back to business, now you want to add your &#8220;incredible&#8221; scripts. Run the ff:\n        </p>\n        \n        <div>\n          > export PATH=$PATH:/usr/local/myscripts/really/great/work/bin\n        </div>\n        \n        <p>\n          Done, now see if Linux can find your script or binary.\n        </p>\n        \n        <div>\n          > which myutility</p> \n          \n          <p>\n            /usr/local/myscripts/really/great/work/bin/myutility</div> \n            \n            <p>\n              Success! Now test your script.\n            </p>\n            \n            <div>\n              > myutility\n            </div>\n            \n            <p>\n            </p>\n            \n            <blockquote>\n              <p>\n                If your script throws an error, you may need to work on it. It may be using hard coded relative paths. Sometimes using absolute paths can do the trick.\n              </p>\n            </blockquote>\n            \n            <p>\n              Yahoo! It works! Now lets take it a bit further, lets configure your system so you don&#8217;t need to keep typing the export-PATH command. Open the ~/.bash_profile file in your favorite text editor.\n            </p>\n            \n            <div>\n              > vi ~/.bash_profile</p> \n              \n              <p>\n                # .bash_profile\n              </p>\n              \n              <p>\n                # Get the aliases and functions<br />if [ -f ~/.bashrc ]; then<br />. ~/.bashrc<br />fi\n              </p>\n              \n              <p>\n                # User specific environment and startup programs\n              </p>\n              \n              <p>\n                PATH=$PATH:$HOME/bin\n              </p>\n              \n              <p>\n                export PATH<br />unset USERNAME</div> \n                \n                <p>\n                </p>\n                \n                <blockquote>\n                  <p>\n                    Note the tilde(~) symbol, this is just shorthand for your home folder. Lets say your username is iamgenius, that should translate to /home/iamgenius/.bash_profile\n                  </p>\n                </blockquote>\n                \n                <p>\n                  Same as what you did earlier, append your script folder to the PATH construct, as shown below\n                </p>\n                \n                <div>\n                  PATH=$PATH:$HOME/bin:/usr/local/myscripts/really/great/work/bin\n                </div>\n                \n                <p>\n                  Now your done, the next time you login, the new &#8220;PATH&#8221; should kick in.\n                </p>\n                \n                <p>\n                  Congratulations! Now go play with your scripts!\n                </p>\n                \n                <p>\n                  <a href=\"//dl.getdropbox.com/u/1510515/potatokorner/potatokorner-tutorial-export-command.pdf\" target=\"_blank\">Download a PDF copy</a>\n                </p>","fields":{"slug":"/use-export-command-to-help-linux-find-your-scripts/"},"frontmatter":{"date":"September 25, 2009","title":"Use Export Command To Help Linux Find Your Scripts","featured_image":null,"tags":["linux","bash","scripts"]}}},{"node":{"excerpt":"Happy New Year! As promised I made a rudimentary Linux shell script utilizing the tar and gzip commands to archive or make backups. If you’re new to shell scripting you might like to read this articles. http://www.dartmouth.edu/~rc/classes/ksh/print_pages.shtml http://tldp.org/LDP/abs/html/ If you’re lazy like I am. Don’t worry I’ll explain parts of the code.","html":"<p>Happy New Year!</p>\n<p>As promised I made a rudimentary Linux shell script utilizing the tar and gzip commands to archive or make backups. If you’re new to shell scripting you might like to read this articles.</p>\n<p><a href=\"http://www.dartmouth.edu/~rc/classes/ksh/print_pages.shtml\">http://www.dartmouth.edu/~rc/classes/ksh/print_pages.shtml</a><br>\n<a href=\"http://tldp.org/LDP/abs/html/\">http://tldp.org/LDP/abs/html/</a></p>\n<p>If you’re lazy like I am. Don’t worry I’ll explain parts of the code.</p>\n<!--more-->\n<p>Our goal is to make a shell script to create backups (in tar-gzip versions) of the folders we want unto a safe location on a disk. We want to be able to list all the folders and have the script loop through them. Now that’s settled, we can proceed to the code.<!--more--></p>\n<p>First, don’t forget to tell linux what scripting interpreter to use. I usually use <span style=\"font-style: italic;\">sh</span> but there are others like <span style=\"font-style: italic;\">bash and ksh</span>. But many experts suggest to use sh for portability to older systems.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/sh</span></code></pre></div>\n<p>Next, we configure the script. The lines below enumerates the folders I want archived ,then stores them in a SHELL VARIABLE named FOLDERS. (duhh!..)</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># — LIST OF FILES/FOLDERS TO BACKUP</span>\n<span class=\"token assign-left variable\">FOLDERS</span><span class=\"token operator\">=</span>”/var/www/html /opt/sandbox”</code></pre></div>\n<p>This line saves the folder path I want the archives to be stored in.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># — BACKUP HERE</span>\n<span class=\"token assign-left variable\">BACKUPFOLDER</span><span class=\"token operator\">=</span>”/opt/backup”</code></pre></div>\n<p><em>REMINDER</em><br>\nMake sure that the backup folder exist. If it doesn’t run the lines below on the console.</p>\n<div style=\"background-color: green; color: white; padding: 10px;\">\n  > mkdir /opt/backup<br /> > chown root:root /opt/backup<br /> > chmod 755 /opt/backup\n</div>\n<p>Here I configure the command string I want to use. Regarding the details of the command I used – see this <a href=\"http://potatokorner.blogspot.com/2008/12/linux-snippet-backup-using-tar-and-gzip.html\">[link]</a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># — ARCHIVE COMMAND</span>\n<span class=\"token assign-left variable\">COMPRESSCMD</span><span class=\"token operator\">=</span>”tar czfv “</code></pre></div>\n<p>Here we use the <span style=\"font-style: italic;\">for</span> command to loop through all the items we listed in <span style=\"font-style: italic;\">$FOLDERS</span> and store it in another variable, <span style=\"font-style: italic;\">$itm</span>.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\">## loop thru folders</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">itm</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$FOLDERS</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n<span class=\"token comment\"># commands here</span>\n….\n<span class=\"token keyword\">done</span></code></pre></div>\n<p>These lines configures the commands we’re going to use inside the loop. The first line generates a formatted file path for my archive, $FARCHIVE.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">FARCHIVE</span><span class=\"token operator\">=</span><span class=\"token variable\">$BACKUPFOLDER</span>/<span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">basename</span> $itm<span class=\"token variable\">`</span></span>_<span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">uname</span> -n<span class=\"token variable\">`</span></span>_<span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">date</span> +%F<span class=\"token variable\">`</span></span>.tgz\n<span class=\"token variable\">$COMPRESSCMD</span> <span class=\"token variable\">$FARCHIVE</span> <span class=\"token variable\">$itm</span></code></pre></div>\n<p>If you’ve noticed I used the tilde symbol(`). Yes they are not single quotation marks. In linux console, any commands enclosed within tildes are ran first and the result is returned as a string. So for example <span style=\"font-style: italic;\">$itm</span> is equal to <span style=\"font-style: italic;\">/var/www/html</span>. The resulting FARCHIVE value will be:</p>\n<div style=\"background-color: green; color: white; padding: 10px;\">\n  > echo $FARCHIVE<br /> /opt/backup/html_potato_2009-01-02.tgz\n</div>\n<p>The second line uses $FARCHIVE as well as the command we configured earlier and runs it.</p>\n<p>For a breakdown of the enclosed commands we used.</p>\n<p>echo the last(base) name in a path string.</p>\n<div style=\"background-color: green; color: white; padding: 10px;\">\n  > basename /var/www/html<br /> html\n</div>\n<p>echo the system’s computer name.</p>\n<div style=\"background-color: green; color: white; padding: 10px;\">\n  > uname -n<br /> potato\n</div>\n<p>echo the current date in this format (YYYY-MM-DD)</p>\n<div style=\"background-color: green; color: white; padding: 10px;\">\n  > date +%F<br /> 2009-01-02\n</div>\n<p>Here is the full script.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/sh</span>\n<span class=\"token comment\">#set -x</span>\n<span class=\"token comment\">#——————————————–</span>\n<span class=\"token comment\"># ID: cabBackup.sh – BACKUP items to folder</span>\n<span class=\"token comment\"># USAGE: ./cabBackup.sh</span>\n<span class=\"token comment\">#——————————————–</span>\n<span class=\"token comment\"># AUTHOR: codespud 2008-2009</span>\n<span class=\"token comment\"># VERSION: 0.01</span>\n\n<span class=\"token comment\"># TODO: arguments</span>\n<span class=\"token comment\"># TODO: config file</span>\n<span class=\"token comment\"># TODO: functions</span>\n<span class=\"token comment\"># TODO: filtering</span>\n\n<span class=\"token comment\"># Sources</span>\n<span class=\"token comment\"># http://www.hsrl.rutgers.edu/ug/shell_help.html</span>\n\n<span class=\"token comment\"># PATH</span>\n<span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span>/opt/bin:/usr/bin:/bin<span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">export</span> <span class=\"token environment constant\">PATH</span>\n\n<span class=\"token comment\"># CONFIG</span>\n\n<span class=\"token comment\"># — LIST OF FILES/FOLDERS TO BACKUP if not specified via console</span>\n\n<span class=\"token assign-left variable\">FOLDERS</span><span class=\"token operator\">=</span>”/var/www/html /opt/sandbox”\n<span class=\"token comment\">#FOLDERS=””</span>\n\n<span class=\"token comment\"># — BACKUP HERE</span>\n<span class=\"token assign-left variable\">BACKUPFOLDER</span><span class=\"token operator\">=</span>”/opt/backup”\n\n<span class=\"token comment\"># — ARCHIVE COMMAND</span>\n<span class=\"token assign-left variable\">COMPRESSCMD</span><span class=\"token operator\">=</span>”tar czfv ”\n\n<span class=\"token comment\"># — DO NOT EDIT BEYOND THIS LINE (unless if you knw what ur doing ;] ) —</span>\n\n<span class=\"token comment\"># Check if the folder exists if not make it</span>\n<span class=\"token punctuation\">[</span> <span class=\"token operator\">!</span> -d <span class=\"token variable\">$BACKUPFOLDER</span> <span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">mkdir</span> -p <span class=\"token variable\">$BACKUPFOLDER</span> <span class=\"token operator\">||</span> <span class=\"token builtin class-name\">:</span>\n\n<span class=\"token function\">chown</span> root:root <span class=\"token variable\">$BACKUPFOLDER</span>\n<span class=\"token function\">chmod</span> <span class=\"token number\">755</span> <span class=\"token variable\">$BACKUPFOLDER</span>\n\n<span class=\"token comment\"># clean the screen</span>\n<span class=\"token function\">clear</span>\n\n<span class=\"token builtin class-name\">echo</span> lets start\n\n<span class=\"token comment\">## loop thru folders</span>\n<span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">itm</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$FOLDERS</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n\n<span class=\"token assign-left variable\">FARCHIVE</span><span class=\"token operator\">=</span><span class=\"token variable\">$BACKUPFOLDER</span>/<span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">basename</span> $itm<span class=\"token variable\">`</span></span>_<span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">uname</span> -n<span class=\"token variable\">`</span></span>_<span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">date</span> +%F<span class=\"token variable\">`</span></span>.tgz\n<span class=\"token variable\">$COMPRESSCMD</span> <span class=\"token variable\">$FARCHIVE</span> <span class=\"token variable\">$itm</span>\n\n<span class=\"token keyword\">done</span>\n\n<span class=\"token builtin class-name\">echo</span> <span class=\"token punctuation\">..</span> <span class=\"token keyword\">done</span></code></pre></div>\n<p>Now name and save the file. I named mine <span style=\"font-weight: bold;\"><span style=\"font-style: italic;\">cabBackup.sh</span></span>.</p>\n<p>You need to make the script executable.</p>\n<div style=\"background-color: green; color: white; padding: 10px;\">\n  > chmod 755 ./cabBackup.sh\n</div>\n<p>There you have it just run it from the console.</p>\n<div style=\"background-color: green; color: white; padding: 10px;\">\n  > ./cabBackup.sh\n</div>\n<p>There are still some things we need to do to make it a fully fledged automation script like configuration files, some pre-process commands and error trapping. But what we have now serves our purpose very well. I’ll post revisions of this script so watch for that.</p>\n<p>Links<br>\n<a href=\"http://www.dartmouth.edu/~rc/classes/ksh/print_pages.shtml\">http://www.dartmouth.edu/~rc/classes/ksh/print_pages.shtml</a><br>\n<a href=\"http://tldp.org/LDP/abs/html/\">http://tldp.org/LDP/abs/html/</a><br>\n<a href=\"http://potatokorner.blogspot.com/2008/12/linux-snippet-backup-using-tar-and-gzip.html\">Linux: Snippet – Backup using Tar and gzip</a></p>","fields":{"slug":"/how-to-write-a-backup-shell-script-using-tar-and-gnu-zip/"},"frontmatter":{"date":"January 02, 2009","title":"How to Write a Backup Shell Script using Tar and Gnu Zip","featured_image":null,"tags":["bash","linux","script"]}}},{"node":{"excerpt":"As a programmer i have to make multiple revisions of a project on a remote site. Getting things wrong and messing up the files tend to happen more often than I am comfortable with. Fortunately, making quick backups in linux is a breeze. You can either make a folder and just copy your existing files via recursive cp command or; archive it using tar and gzip. Personally, I prefer archives since they tend to be smaller and easy to manage.","html":"<p>As a programmer i have to make multiple revisions of a project on a remote site. Getting things wrong and messing up the files tend to happen more often than I am comfortable with. Fortunately, making quick backups in linux is a breeze. You can either make a folder and just copy your existing files via recursive cp command or; archive it using tar and gzip. Personally, I prefer archives since they tend to be smaller and easy to manage. <!--more--></p>\n <div>\n<span style=\"font-weight: bold;\"><span ><span>Install tar and gzip</span></span></span>\n</div>\n  \n <div>\n<span ><span> You can be hardcore and download the source for tar and gzip and recompile them.</span></span>\n</div>\n  \n <div>\n<span style=\"font-size: 13px;\"> </span>\n</div>\n  \n <div>\n<a href=\"http://www.gnu.org/software/tar\"><span>http://www.gnu.org/software/tar/</span></a>\n</div>\n  \n <div>\n<a href=\"http://www.gzip.org/\"><span>http://www.gzip.org/</span></a>\n</div>\n  \n \n  \n <div>\n<span> Or you can use apt-get or yum(Yellow dog Updater, Modified ? &#8212; weird name ) to do it for you.</span>\n</div>\n  \n \n  \n <div>\n<span> yum install tar</span>\n</div>\n  \n <div>\n<span> yum install gzip</span>\n</div>\n  \n \n  \n <div>\n<span style=\"font-weight: bold;\">Sample commands</span>\n</div>\n  \n \n  \n <div>\n<span style=\"font-weight: bold;\">Archive a folder ( -c means create )</span>\n</div>\n  \n <pre><span style=\"color: #009900;\">tar cvf - folder | gzip &gt; archive.tar.gz</span></pre>\n  \n <div>\n<span style=\"font-family: 'courier new';\">Archive a file</span>\n</div>\n  \n <pre><span style=\"font-style: italic;\"><span style=\"color: #009900;\">tar cvf - filename | gzip &gt; archive.tar.gz</span></pre>\n  \n <div>\n<span style=\"font-weight: bold;\">Archive files</span></span></span>\n</div>\n  \n <pre><span style=\"font-style: italic;\"><span style=\"color: #009900;\">tar cvf - filename1 filename2 | gzip &gt; archive.tar.g</span></pre>\n  \n <div>\n<span style=\"font-weight: bold;\">Alternative format (-z means use gzip to compress)</span></span></span>\n</div>\n  \n <pre><span style=\"font-style: italic;\"><span style=\"color: #009900;\">tar cvzf /path/to/dir/archive.tar.gz filename</span></pre>\n  \n <pre><span style=\"font-style: italic;\"><span style=\"color: #009900;\">tar cvzf /path/to/dir/archive.tar.gz filename1 filename</span></pre>\n  \n <div>\n<span style=\"font-weight: bold;\">Extracting (-x means extract )</span></span></span>\n</div>\n  \n <pre><span style=\"font-style: italic;\"><span style=\"color: #009900;\">tar xvzf /path/to/dir/archive.tar.gz</span></pre>\n  \n \n  \n <div>\n<span> There are other ways and tools to make your archives. But we&#8217;ll continue with that some other time. For the really lazy, I&#8217;ll make a bash script that uses tar and gzip in a later post so watch for that.</span></span>\n</div>\n  \n \n  \n <div>\n<span ><span> I hope my article helped some newbies out there. Mabuhay!</span></span>\n</div>","fields":{"slug":"/linux-snippet-backup-using-tar-and-gzip/"},"frontmatter":{"date":"December 07, 2008","title":"Linux: Snippet – Backup using Tar and gzip","featured_image":"/linux-logo.jpg","tags":["linux","script","bash"]}}}]}},"pageContext":{"tag":"bash"}}}